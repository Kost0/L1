// Паттерн адаптер стоит использовать в случаях:
//  - если нужно использовать сторонний класс, интерфейс которого
// не соответствует остальному коду программы
//  - если нужно использовать несколько подклассов, но в них не
// хватает функциональности, а расширить суперкласс нет возможности

// Плюсы:
//  - Скрывает от клиента подробности преобразования интерфейсов
//  - Позволяет использовать старый или сторонний код по новому
// Минусы:
//  - Увеличивается объем кода, он становится сложнее для чтения, понимания и отладки
//  - Увеличивает нагрузку

// Примеры:
//  - В проекте использовался один логгер, что-то произошло, и было решено
// использовать другую библиотеку для логирования, чтобы не трогать бизнес-логику,
// можно использовать адаптер.
//  - В проекте необходимо работать с разными API, методы для работы с ними отличаются,
// но выполняют одно и то же. Можно написать адаптер, чтобы бизнес-логика не зависела
// от используемого клиента
//  - В проекте необходимо работать с разными базами данных. Так как отличаются
// диалекты SQl и драйвера, можно написать адаптер, для выполнения одних и тех же
// запросов, но в разные бд

package main

import "fmt"

// Интерфейс с методом Speak()
type Human interface {
	Speak() string
}

// Структура, которая не реализует интерфейс Human
type SuperHuman struct {
}

// Функция отличная от Speak
func (suh SuperHuman) SuperSpeak() string {
	return "Super hello world"
}

// Структура, которой нужен интерфейс Human
type Consumer struct {
	Human
}

// Адаптер, который адаптирует SuperHuman к Human
type Adapter struct {
	SuperHuman
}

// Функция удовлетворяющая интерфейсу Human
func (a Adapter) Speak() string {
	return a.SuperSpeak()
}

func main() {
	// Создаем SuperHuman
	s := SuperHuman{}
	// Создаем адаптер, передаем ему SuperHuman
	a := Adapter{s}
	// Потребитель получает адаптер, в котором лежит SuperHuman
	c := Consumer{a}
	// Но удовлетворяет интерфейсу Human
	fmt.Println(c.Speak())
}
